using RazerSdkReader.Structures;
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;

namespace RazerSdkReader.Extensions;

public static class ChromaEncryption
{
    private static readonly uint[] Key;

    /// <summary>
    ///     PreProcesses the key format found inside the disassembly into
    ///     a custom format that better takes advantage of SIMD instructions.
    ///     This speeds up decryption significantly.
    ///
    ///     The processing is done once at runtime instead of being done ahead-of-time
    ///     just for the sake of simplicity. I want to keep the original key as close
    ///     to the disassembly as I can, so that if we ever need to change it we can.
    /// </summary>
    static ChromaEncryption()
    {
        ReadOnlySpan<byte> originalKey =
        [
            0x45, 0x86, 0x56, 0x02, 0x34, 0x86, 0x27, 0xF6, 0xD6, 0x16, 0x02, 0x75,
            0xF6, 0x27, 0xB6, 0x37, 0x86, 0xF6, 0x07, 0x02, 0x96, 0x37, 0x02, 0x97,
            0xF6, 0x57, 0x27, 0x02, 0xF6, 0xE6, 0x56, 0xD2, 0x37, 0x47, 0xF6, 0x07,
            0xD2, 0x37, 0x86, 0xF6, 0x07, 0x02, 0x47, 0xF6, 0x02, 0x76, 0x56, 0x47,
            0x02, 0x47, 0x86, 0x56, 0x02, 0xD6, 0xF6, 0x37, 0x47, 0x02, 0xF6, 0x57,
            0x47, 0x02, 0xF6, 0x66, 0x02, 0x97, 0xF6, 0x57, 0x27, 0x02, 0x34, 0x86,
            0x27, 0xF6, 0xD6, 0x16, 0x02, 0x46, 0x56, 0x67, 0x96, 0x36, 0x56, 0x37,
            0xE2, 0x02, 0x02, 0x75, 0x86, 0x56, 0x47, 0x86, 0x56, 0x27, 0x02, 0x96,
            0x47, 0x72, 0x37, 0x02, 0x37, 0xD6, 0x16, 0x27, 0x47, 0x02, 0xC6, 0x96,
            0x76, 0x86, 0x47, 0x96, 0xE6, 0x76, 0x02, 0x26, 0x16, 0x37, 0x56, 0x46,
            0x02, 0xF6, 0xE6, 0x02, 0x96, 0xE6, 0xD2, 0xF6, 0x75, 0x56, 0x29, 0x27,
            0x56, 0x02, 0x07, 0x57, 0x37, 0x86, 0x96, 0xE6, 0x76, 0x02, 0x47, 0x86,
            0x56, 0x02, 0xC6, 0x96, 0xD6, 0x96, 0x47, 0x37, 0x02, 0x47, 0xF6, 0x02,
            0x77, 0x86, 0x16, 0x47, 0x02, 0x16, 0x02, 0x76, 0x16, 0xD6, 0x96, 0xE6,
            0x76, 0x02, 0xC6, 0x16, 0x07, 0x47, 0xF6, 0x07, 0x02, 0x36, 0x16, 0xE6,
            0x02, 0x46, 0xF6, 0xE2, 0x02, 0x45, 0x86, 0x56, 0x02, 0x25, 0x16, 0xA7,
            0x56, 0x27, 0x02, 0x24, 0xC6, 0x16, 0x46, 0x56, 0x02, 0x05, 0x27, 0xF6,
            0x02, 0x13, 0x73, 0x02, 0x96, 0x37, 0x02, 0x26, 0x57, 0x96, 0xC6, 0x47,
            0x02, 0x77, 0x96, 0x47, 0x86, 0x02, 0x16, 0x02, 0x07, 0xF6, 0x77, 0x56,
            0x27, 0x66, 0x57, 0xC6, 0x02, 0x07, 0x27, 0xF6, 0x36, 0x56, 0x37, 0x37,
            0xF6, 0x27, 0x02, 0x47, 0xF6, 0x02, 0x27, 0x57, 0xE6, 0x02, 0x07, 0x56,
            0x27, 0x66, 0xF6, 0x12, 0x24, 0x57, 0x96, 0xC6, 0x47, 0x02, 0x96, 0xE6,
            0x47, 0xF6, 0x02, 0xF6, 0x57, 0x27, 0x02, 0x44, 0xE4, 0x14, 0xC2, 0x02,
            0x47, 0x86, 0x56, 0x02, 0x25, 0x16, 0xA7, 0x56, 0x27, 0x02, 0x05, 0x86,
            0xF6, 0xE6, 0x56, 0x02, 0x23, 0x02, 0x66, 0x56, 0x16, 0x47, 0x57, 0x27,
            0x56, 0x37, 0x02, 0x16, 0xE6, 0x02, 0x96, 0xC6, 0xC6, 0x57, 0xD6, 0x96,
            0xE6, 0x16, 0x47, 0x56, 0x46, 0x02, 0x25, 0x16, 0xA7, 0x56, 0x27, 0x02,
            0xC6, 0xF6, 0x76, 0xF6, 0x02, 0x77, 0x96, 0x47, 0x86, 0x02, 0x36, 0x57,
            0x37, 0x47, 0xF6, 0xD6, 0x96, 0xA7, 0x16, 0x26, 0xC6, 0x56, 0x02, 0x25,
            0x16, 0xA7, 0x56, 0x27, 0x02, 0x34, 0x86, 0x27, 0xF6, 0xD6, 0x16, 0x99,
            0x02, 0x25, 0x74, 0x24, 0x02, 0xC6, 0x96, 0x76, 0x86, 0x47, 0x96, 0xE6,
            0x76, 0xE2, 0x02, 0x95, 0xF6, 0x57, 0x27, 0x02, 0xD6, 0xF6, 0x26, 0xBB,
            0x45, 0x86, 0x56, 0x02, 0x25, 0x16, 0xA7, 0x56, 0x27, 0x02, 0x34, 0x86,
            0x27, 0xF6, 0xD6, 0x16, 0x02, 0x34, 0xF6, 0xE6, 0xE6, 0x56, 0x36, 0x47,
            0x56, 0x46, 0x02, 0x44, 0x56, 0x67, 0x96, 0x36, 0x56, 0x37, 0x02, 0x05,
            0x27, 0xF6, 0x76, 0x27, 0x16, 0xD6, 0x02, 0x77, 0x96, 0xC6, 0xC6, 0x02,
            0x56, 0xE6, 0x16, 0x26, 0xC6, 0x56, 0x02, 0x07, 0x16, 0x27, 0x47, 0xE6,
            0x56, 0x27, 0x37, 0x02, 0x47, 0xF6, 0x02, 0x56, 0xE6, 0x16, 0x26, 0xC6,
            0x56, 0x02, 0x34, 0x86, 0x27, 0xF6, 0xD6, 0x16, 0x02, 0xC6, 0x96, 0x76,
            0x86, 0x47, 0x96, 0xE6, 0x76, 0x02, 0x47, 0x86, 0x27, 0xF6, 0x57, 0x76,
            0x86, 0x02, 0x16, 0x02, 0x37, 0x96, 0xE6, 0x76, 0xC6, 0x56, 0x02, 0x36,
            0xC6, 0x96, 0x36, 0xB6, 0x02, 0xF6, 0xE6, 0x02, 0x47, 0x86, 0x56, 0x96,
            0x27, 0x02, 0x37, 0xF6, 0x66, 0x47, 0x77, 0xA0
        ];

        Key = new uint[originalKey.Length / 4];

        for (var i = 0; i < Key.Length; i++)
        {
            var correctedIndex = i;
            if (correctedIndex > 124)
            {
                correctedIndex -= 3;
            }

            var r = originalKey[0 * 128 + 0 + correctedIndex];
            var g = originalKey[1 * 128 + 1 + correctedIndex];
            var b = originalKey[2 * 128 + 2 + correctedIndex];
            var a = originalKey[3 * 128 + 3 + correctedIndex];

            Key[i] = BitConverter.ToUInt32([r, g, b, a]);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChromaColor Decrypt(uint color, ChromaTimestamp timestamp)
    {
        var key = Key[timestamp.TickCount64 % 128];

        //Set the alpha channel to 0xFF, it's not used in the decryption process
        return ChromaColor.FromSdkColor(color ^ key | 0xFF000000);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Decrypt(ReadOnlySpan<uint> input, Span<ChromaColor> output, ChromaTimestamp timestamp)
    {
        //https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/vectorization-guidelines.md
        var length = Math.Min(input.Length, output.Length);
        var key = Key[timestamp.TickCount64 % 128];
        var lengthAsBytes = length * sizeof(uint);

        if (!Vector256.IsHardwareAccelerated || lengthAsBytes < Vector256<byte>.Count)
        {
            for (var i = 0; i < length; i++)
            {
                output[i] = ChromaColor.FromSdkColor(input[i] ^ key | 0xFF000000);
            }

            return;
        }
        var inputAsBytes = MemoryMarshal.Cast<uint, byte>(input);
        var outputAsBytes = MemoryMarshal.Cast<ChromaColor, byte>(output);

        ref var searchSpace = ref MemoryMarshal.GetReference(inputAsBytes);
        var oneVectorAwayFromEnd = (nuint)(lengthAsBytes - Vector256<byte>.Count);
        nuint offset = 0;
        while (offset <= oneVectorAwayFromEnd)
        {
            Vector256.Shuffle(
                (Vector256.LoadUnsafe(ref searchSpace, offset) ^ Vector256.Create<uint>(key).As<uint, byte>())
                    | Vector256.Create<uint>(0xFF000000).As<uint, byte>(),
                Vector256.Create(
                    (byte)02, 01, 00, 03, 06, 05, 04, 07,
                    10, 09, 08, 11, 14, 13, 12, 15,
                    18, 17, 16, 19, 22, 21, 20, 23,
                    26, 25, 24, 27, 30, 29, 28, 31
                )
            ).StoreUnsafe(ref MemoryMarshal.GetReference(outputAsBytes), offset);
            offset += (nuint)Vector256<byte>.Count;
        }

        //we processed what we could above. Anything after a multiple of 8 is processed here.
        //we will process a few elements twice, but the operation is idempotent, and it's faster
        //than reverting to a scalar loop.
        if (offset != (uint)lengthAsBytes)
        {
            offset = (nuint)(lengthAsBytes - Vector256<byte>.Count);
            Vector256.Shuffle(
                (Vector256.LoadUnsafe(ref searchSpace, offset) ^ Vector256.Create<uint>(key).As<uint, byte>())
                        | Vector256.Create<uint>(0xFF000000).As<uint, byte>(),
                Vector256.Create(
                    (byte)02, 01, 00, 03, 06, 05, 04, 07,
                    10, 09, 08, 11, 14, 13, 12, 15,
                    18, 17, 16, 19, 22, 21, 20, 23,
                    26, 25, 24, 27, 30, 29, 28, 31
                )
            ).StoreUnsafe(ref MemoryMarshal.GetReference(outputAsBytes), offset);
        }
    }
}